
%%% ================================================================
%%% FILE: plan_loader_spiral.pl
%%% Purpose: Loader/adapter to run spiral planner on existing plans
%%% Exports: load_plan/1, apply_plan/0, clear_plan/0,
%%%          solve_plan_spiral/3, solve_plan_spiral_to_file/1,2
%%% ================================================================
:- module(plan_loader_spiral,
  [ load_plan/1,
    apply_plan/0,
    clear_plan/0,
    solve_plan_spiral/3,          % -Rects,-Oris,-Grid
    solve_plan_spiral_to_file/1,  % +OutFile
    solve_plan_spiral_to_file/2,   % +OutFile,+Format(json|pl)
    solve_plan_spiral_oriented/3
  ]).

:- use_module(rects).
:- use_module(zones).
:- use_module(layout_spiral).
:- use_module(library(http/json)).
:- use_module(library(option)).
:- use_module(orient_spiral).


:- multifile layout_spiral:progress_hook/1.
:- dynamic  current_plan_module/1.

/* ----------------- Public API ----------------- */
load_plan(File) :-
    absolute_file_name(File, Abs, [access(read)]),
    load_files(Abs, [silent(true)]),
    detect_plan_module(Abs, M),
    retractall(current_plan_module(_)),
    asserta(current_plan_module(M)),
    apply_plan.

apply_plan :-
    current_plan_module(M),
    clear_plan,
    map_room(M),
    map_objects(M).

clear_plan :-
    retractall(rects:room_size(_,_)),
    retractall(zones:door(_,_,_,_)),
    retractall(zones:e_panel(_,_,_)),
    retractall(zones:net_cab(_,_,_,_)),
    retractall(zones:forbidden_zone(_,_,_)),
    retractall(zones:policy(_,_)).

solve_plan_spiral(Rects, Oris, Grid) :-
    current_plan_module(M),
    ( predicate_property(M:task(_,_), defined)
    -> clause(M:task(Count, size(W,H)), true),
       %%% NEW: включаем поиск оффсетов сетки
       layout_spiral:layout_tiles_spiral_opts(
           Count, W,H,
           _{ offset_search:auto },     % можно заменить на grid_offsets/[...]
           Rects, Oris, Meta),
       Grid = Meta.grid_mm
    ;  throw(error(existence_error(predicate, M:task/2), _))
    ).
solve_plan_spiral_to_file(File) :-
    ( file_name_extension(_, json, File) ->
        solve_plan_spiral_to_file(File, json)
    ;   solve_plan_spiral_to_file(File, pl)
    ).

solve_plan_spiral_to_file(File, Format) :-
    solve_plan_spiral(Rects, Oris, Grid),
    open(File, write, S, [encoding(utf8)]),
    ( Format == json ->
        maplist(rect_ori_dict(Grid, _W0=_, _H0=_), Rects, Oris, Dicts),
        Sol = _{ grid: Grid, desks: Dicts },
        json_write_dict(S, Sol, [width(0)]), nl(S)
    ; % Prolog facts
      format(S, '% generated by spiral planner~n', []),
      format(S, 'solution(grid(~w)).~n~n', [Grid]),
      forall(nth1(I,Rects,R),
        ( nth1(I,Oris,O), R = rect(X,Y,W,H),
          format(atom(Id), 'desk-~d', [I]),
          format(S, 'placed_object(~q, desk, rect(~w,~w,~w,~w), [orientation(~w)]).~n',
                 [Id, X,Y,W,H, O])
        ))
    ),
    close(S).

rect_ori_dict(Grid, _W0, _H0, rect(X,Y,W,H), Ori, D) :-
    gensym('desk-', Sym),
    D = _{ id:Sym, type:desk, rect:_{x:X,y:Y,w:W,h:H}, orientation:Ori, grid:Grid }.

/* ----------------- Mapping plan → zones ----------------- */

detect_plan_module(Abs, M) :-
    ( module_property(M0, file(Abs)) -> M = M0
    ; find_module_with_pred(room/1,         M1) -> M = M1
    ; find_module_with_pred(static_object/4, M2) -> M = M2
    ; find_module_with_pred(task/2,          M3) -> M = M3
    ; M = user
    ).

find_module_with_pred(Name/Arity, M) :-
    functor(Head, Name, Arity),
    current_module(M),
    predicate_property(M:Head, defined), !.

map_room(M) :-
    ( predicate_property(M:room(_), defined)
    -> clause(M:room(size(W,H)), true), asserta(rects:room_size(W,H))
    ;  throw(error(existence_error(predicate, M:room/1), _))
    ).

map_objects(M) :-
    ( predicate_property(M:static_object(_,_,_,_), defined)
    -> forall(clause(M:static_object(Id,Type,Rect,Props), true), map_object(Id, Type, Rect, Props))
    ;  true ).

map_object(Id, door, Rect, _Props) :- !,
    door_rect_to_side_offset_width(Rect, Side, Off, Wd),
    asserta(zones:door(Id, side(Side), offset(Off), width(Wd))).
map_object(Id, window, Rect, _Props) :- !,
    window_clear_zone(Rect, Z),
    asserta(zones:forbidden_zone(Id, window_clear, Z)).
map_object(Id, column, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, struct, Rect)).
map_object(Id, cabinet, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, struct, Rect)).
map_object(Id, electrical_shield, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, struct, Rect)),
    panel_service_zone(Rect, Z), asserta(zones:forbidden_zone(service(Id), service, Z)).
map_object(Id, net_cabinet, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, struct, Rect)),
    netcab_service_zone(Rect, Z), asserta(zones:forbidden_zone(service(Id), service, Z)).
map_object(Id, fire_extinguisher, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, marker_fe, Rect)).
map_object(Id, fire_alarm, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, marker_fa, Rect)).
map_object(Id, comms_block, Rect, _Props) :- !,
    asserta(zones:forbidden_zone(Id, marker_comms, Rect)).
map_object(Id, Unknown, Rect, _Props) :-
    print_message(warning, plan_loader_spiral(unknown_type(Unknown, Id))),
    asserta(zones:forbidden_zone(Id, struct, Rect)).

/* ---- wall/door utilities (copied from your loaders) ---- */
door_rect_to_side_offset_width(rect(X,Y,W,H), Side, Off, Wd) :-
    rects:room_size(Wr,Hr), X2 is X+W, Y2 is Y+H,
    ( Y =:= 0   -> Side = north, Off = X,   Wd = W
    ; Y2 =:= Hr -> Side = south, Off = X,   Wd = W
    ; X =:= 0   -> Side = west,  Off = Y,   Wd = H
    ; X2 =:= Wr -> Side = east,  Off = Y,   Wd = H
    ; throw(error(domain_error(door_on_wall, rect(X,Y,W,H)), _)) ).

window_clear_zone(rect(X,Y,W,H), rect(Xz,Yz,Wz,Hz)) :-
    rects:room_size(Wr,Hr), ( zones:policy(window_clear_depth_mm, D) -> true ; D = 1000 ),
    X2 is X+W, Y2 is Y+H,
    ( Y =:= 0   -> Xz is X,     Yz is 0,     Wz is W,  Hz is D
    ; Y2 =:= Hr -> Xz is X,     Yz is Hr-D,  Wz is W,  Hz is D
    ; X =:= 0   -> Xz is 0,     Yz is Y,     Wz is D,  Hz is H
    ; X2 =:= Wr -> Xz is Wr-D,  Yz is Y,     Wz is D,  Hz is H
    ; fail ).

panel_service_zone(rect(X,Y,W,H), rect(Xz,Yz,Wz,Hz)) :-
    rects:room_size(Wr,Hr), ( zones:policy(panel_clear_size, size(Along,Depth)) -> true ; (Along=1000,Depth=1000) ),
    X2 is X+W, Y2 is Y+H,
    ( Y =:= 0   -> Xz is X,     Yz is 0,        Wz is Along, Hz is Depth
    ; Y2 =:= Hr -> Xz is X,     Yz is Hr-Depth, Wz is Along, Hz is Depth
    ; X =:= 0   -> Xz is 0,     Yz is Y,        Wz is Depth, Hz is Along
    ; X2 =:= Wr -> Xz is Wr-Depth, Yz is Y,     Wz is Depth, Hz is Along
    ; fail ).

netcab_service_zone(rect(X,Y,W,H), rect(Xz,Yz,Wz,Hz)) :-
    rects:room_size(Wr,Hr), ( zones:policy(netcab_clear_depth, D) -> true ; D = 1000 ),
    X2 is X+W, Y2 is Y+H,
    ( Y =:= 0   -> Xz is X,     Yz is 0,     Wz is W,  Hz is D
    ; Y2 =:= Hr -> Xz is X,     Yz is Hr-D,  Wz is W,  Hz is D
    ; X =:= 0   -> Xz is 0,     Yz is Y,     Wz is D,  Hz is H
    ; X2 =:= Wr -> Xz is Wr-D,  Yz is Y,     Wz is D,  Hz is H
    ; fail ).

solve_plan_spiral_oriented(Rects, Oris, Grid) :-
    current_plan_module(M),
    ( predicate_property(M:task(_,_), defined)
    -> clause(M:task(Count, size(W,H)), true),
       layout_spiral:layout_tiles_spiral_opts(
           Count, W,H,
           _{ offset_search:auto },           % как и раньше
           Rects, _Oris0, Meta),
       Grid = Meta.grid_mm,
       % собрать двери из facts
       findall(door(Id,side(S),offset(Off),width(Wd)),
               zones:door(Id,side(S),offset(Off),width(Wd)),
               Doors),
       orient_spiral:orient_tiles(Rects, Meta, Doors, Oris, _Proof)
    ;  throw(error(existence_error(predicate, M:task/2), _))
    ).


solve_plan_spiral_oriented_to_file(File) :-
    ( file_name_extension(_, json, File)
      -> solve_plan_spiral_oriented_to_file(File, json)
       ; solve_plan_spiral_oriented_to_file(File, pl)
    ).

solve_plan_spiral_oriented_to_file(File, json) :-
    (   solve_plan_spiral_oriented(Rects, Oris, Grid)
    ->  maplist(rect_ori_dict(Grid, _W0=_, _H0=_), Rects, Oris, Dicts),
        Sol = _{ grid: Grid, desks: Dicts },
        open(File, write, S, [encoding(utf8)]),
        json_write_dict(S, Sol, [width(0)]), nl(S),
        close(S)
    ;   print_message(error, spiral(failed_stage(solve_plan_spiral_oriented))),
        fail
    ).

solve_plan_spiral_oriented_to_file(File, pl) :-
    solve_plan_spiral_oriented(Rects, Oris, Grid),
    open(File, write, S, [encoding(utf8)]),
    format(S, '% generated by spiral planner (oriented)~n', []),
    format(S, 'solution(grid(~w)).~n~n', [Grid]),
    forall(nth1(I,Rects,rect(X,Y,W,H)),
      ( nth1(I,Oris,O),
        format(atom(Id), 'desk-~d', [I]),
        format(S, 'placed_object(~q, desk, rect(~w,~w,~w,~w), [orientation(~w)]).~n',
               [Id, X,Y,W,H, O])
      )),
    close(S).